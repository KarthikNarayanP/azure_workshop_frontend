resources:
 repositories:
 - repository: FrontendRepo
   endpoint: AZUREMYSERVICECONNECTION
   type: git
   name: azure_workshop_frontend
 - repository: BackendRepo
   endpoint: AZUREMYSERVICECONNECTION
   type: git
   name: azure_workshop_backend
stages:
- stage: BUILD_PIPELINE_FRONTEND
  displayName: BUILD PIPELINE FRONTEND
  jobs:
  - job: PREBUILD_QA
    displayName: DEVELOPER QUALITY GATE
    continueOnError: false
    pool:
        vmImage: 'ubuntu-latest'
    variables:
        privateIP: $(publicIP)
        region: $(regionprimary)
        bucket: $(bucketurl)
        username: $(userkey)
        password: $(secretkey)
        tenant: $(tenantkey)
    steps:
      - checkout: FrontendRepo
        persistCredentials: true
      - bash: |
          echo "Environmental Valued"
      - task: NodeTool@0
        inputs:
          versionSpec: '12.x'
      - script: |
          echo "Environmental Value $(backendPublicIP)"
          npm install
        displayName: 'Install Dependencies'
        
      - script: |
          export dashboardIP=$(dashboardIP)
          export backendIP=$(sonarIP)
          npm run scan
        displayName: 'Static Code Analysis'

      - script: |
          export dashboardIP=$(dashboardIP)
          export backendIP=$(sonarIP)
          npm test
        displayName: 'Unit Test'
        continueOnError: false
      - script: |
          export dashboardIP=$(dashboardIP)
          export backendIP=$(sonarIP)
          npm run scan
        displayName: 'Code Coverage'
      - task: PublishTestResults@2
        condition: succeededOrFailed()
        inputs:
          testRunner: JUnit
          testResultsFiles: 'test/results/junit.xml'
          buildConfiguration: 
      - task: PublishCodeCoverageResults@1
        inputs: 
          codeCoverageTool: Cobertura
          summaryFileLocation: '$(System.DefaultWorkingDirectory)/test/results/coverage/clover.xml'
          reportDirectory: '$(System.DefaultWorkingDirectory)/test/results/coverage'
      
  - job: BUILD
    displayName: BUILD AND PUSH TO ACR
    pool:
        vmImage: 'ubuntu-latest'
    steps:
      - checkout: FrontendRepo
      - script: |
          docker build -t digitalshopify:latest .
        displayName: 'Build Docker Image'
      - script: |
          docker login $(acrRegistry) --username 00000000-0000-0000-0000-000000000000 --password $(azureACRToken)
          docker tag digitalshopify $(acrRegistry)/digitalshopify
          docker push $(acrRegistry)/digitalshopify
        displayName: 'Push Docker Image to ACR'
    dependsOn: PREBUILD_QA
    condition: succeeded()

    # download the artifact and deploy it only if the build job succeeded
  - job: DEPLOY_WITH_VIRTUAL_SERVICES_TO_AKS
    displayName: DEPLOY WITH VIRTUAL SERVICES TO AKS
    pool:
        vmImage: 'ubuntu-latest'
    steps:
    - checkout: none
    - task: Kubernetes@1
      inputs:
        connectionType: Kubernetes Service Connection
        kubernetesServiceEndpoint: MYAKSCONNECTION
        command: login
      displayName: 'Login to AKS'
    - task: Bash@3
      displayName: 'Deployment'        
      inputs:
        targetType: 'inline'
        script: |
          ( kubectl create secret docker-registry mykubetokenacr --docker-server=$(acrRegistry) --docker-username=00000000-0000-0000-0000-000000000000 --docker-password=$(azureACRToken) ) 2>/dev/null || true
          ( kubectl delete service/frontend service/frontend-pod-loadbalancer service/backend-pod-loadbalancer ) 2>/dev/null || true
          ( kubectl delete pod/backend pod/frontend ) 2>/dev/null || true
          kubectl run backend --image=$(acrRegistry)/digitalshopify --overrides='{ "apiVersion": "v1", "spec": { "imagePullSecrets": [{"name": "mykubetokenacr"}] } }' --port=8180
          kubectl expose pod backend --port=8180 --target-port=8180 --name=backend-pod-loadbalancer --type=LoadBalancer
          bash -c 'external_ip=""; while [ -z $external_ip ]; do echo "Waiting for end point..."; external_ip=$(kubectl get svc backend-pod-loadbalancer --template="{{range .status.loadBalancer.ingress}}{{.ip}}{{end}}"); [ -z "$external_ip" ] && sleep 10; done; echo "End point ready-" && echo $external_ip; export endpoint=$external_ip'
          externalip=$(kubectl get services/backend-pod-loadbalancer -o json | jq '.status.loadBalancer.ingress[0].ip' | tr -d '"')
          echo $externalip
          kubectl run frontend --image=$(acrRegistry)/digitalshopify --overrides='{ "apiVersion": "v1", "spec": { "imagePullSecrets": [{"name": "mykubetokenacr"}] } }' --port=3000 --expose=true --env="REACT_APP_API=$externalip" -- npm start
          kubectl expose pod frontend --port=3000 --target-port=3000 --name=frontend-pod-loadbalancer --type=LoadBalancer
          bash -c 'external_ip=""; while [ -z $external_ip ]; do echo "Waiting for end point..."; external_ip=$(kubectl get svc frontend-pod-loadbalancer --template="{{range .status.loadBalancer.ingress}}{{.ip}}{{end}}"); [ -z "$external_ip" ] && sleep 10; done; echo "End point ready-" && echo $external_ip; export endpoint=$external_ip'
          externalipfront=$(kubectl get services/frontend-pod-loadbalancer -o json | jq '.status.loadBalancer.ingress[0].ip' | tr -d '"')
          curl -s --connect-timeout 8 -d "{\"frontendDevIP\":\"$externalipfront\"}"   -H 'Content-Type:application/json' http://$(dashboardIP):3337/api/v1/azure_dashboard_report/secrets/updateprebuildinfra || true
          curl -s --connect-timeout 8 -d "{\"moduleName\":\"prebuild\",\"status\":\"Completed\"}"   -H 'Content-Type:application/json' http://$(dashboardIP):3337/api/v1/azure_dashboard_report/moudule/updatebuildcompletion || true
    dependsOn: BUILD
    condition: succeeded()
  - job: BVT_SYSTEM_TESTS
    displayName: BVT - UI TESTS
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - bash: |
        echo "Environmental Valued"
      env:
        backendIP: $(backendPublicIP)
        publicIP: $(backendPublicIP)
    - task: NodeTool@0
      inputs:
        versionSpec: '12.x'
    - script: |
        echo "Environmental Value $(backendPublicIP)"
        npm install
      displayName: 'Install Dependencies'
  
    - script: |
        npm run cli
      displayName: 'UI System Tests'
    dependsOn: DEPLOY_WITH_VIRTUAL_SERVICES_TO_AKS
    condition: succeeded()
- stage: BUILD_PIPELINE_BACKEND
  displayName: BUILD PIPELINE BACKEND
  dependsOn: []
  jobs:
    - job: PREBUILD_QA
      displayName: DEVELOPER QUALITY GATE
      pool:
        vmImage: 'ubuntu-latest'
      variables:
        backendIP: $(publicIP)
      steps:
      - checkout: BackendRepo
        persistCredentials: true
      - script: |
          export backendIP=$(sonarIP)
          export INSTRUMENTATION_KEY=$(INSTRUMENTATION_KEY)
          chmod +x gradlew
          ./gradlew clean sonarqube
          curl -s --connect-timeout 8 -d "{\"moduleName\":\"codecoverage_static_api\",\"status\":\"Completed\"}"   -H 'Content-Type:application/json' http://$backendIP:3337/api/v1/azure_dashboard_report/moudule/update || true
        displayName: 'Static Code Analysis'
      - script: |
          export backendIP=$(sonarIP)
          export INSTRUMENTATION_KEY=$(INSTRUMENTATION_KEY)
          chmod +x gradlew
          ./gradlew clean codeCoverageReport sonarqube
        displayName: 'Unit Test'
      - task: PublishTestResults@1
        condition: succeededOrFailed()
        inputs:
          testRunner: JUnit
          testResultsFiles: '**/TEST-*.xml'
          mergeTestResults: true
      - task: PublishCodeCoverageResults@1
        condition: succeededOrFailed()
        inputs: 
            codeCoverageTool: JaCoCo
            summaryFileLocation: 'build/reports/jacoco/codeCoverageReport/codeCoverageReport.xml'
            reportDirectory: 'build/reports/jacoco/codeCoverageReport/html'
    - job: BUILD
      displayName: BUILD AND PUSH TO ACR
      pool:
          vmImage: 'ubuntu-latest'
      steps:
        - checkout: BackendRepo
        - script: |
            export INSTRUMENTATION_KEY=$(INSTRUMENTATION_KEY)
            chmod +x ./gradlew
            ./gradlew clean build
            docker-compose build
          displayName: 'Build Docker Image'
        - script: |
            docker login $(acrRegistry) --username 00000000-0000-0000-0000-000000000000 --password $(azureACRToken)
            docker tag ctsshop/service-registry-1.0.jar:v1.0 $(acrRegistry)/ctsshop/service-registry-1.0.jar:v1.0
            docker push $(acrRegistry)/ctsshop/service-registry-1.0.jar:v1.0
          displayName: 'Push SERVICE-REGISTRY Docker Image to ACR'
        - script: |
            docker tag ctsshop/catalogue-service-1.0.jar:v1.0 $(acrRegistry)/ctsshop/catalogue-service-1.0.jar:v1.0
            docker push $(acrRegistry)/ctsshop/catalogue-service-1.0.jar:v1.0
          displayName: 'Push CATALOGUE-SERVICE Docker Image to ACR'
        - script: |
            docker tag ctsshop/customer-service-1.0.jar:v1.0 $(acrRegistry)/ctsshop/customer-service-1.0.jar:v1.0
            docker push $(acrRegistry)/ctsshop/customer-service-1.0.jar:v1.0
          displayName: 'Push CUSTOMER-SERVICE Docker Image to ACR'
        - script: |
            docker tag ctsshop/image-service-1.0.jar:v1.0 $(acrRegistry)/ctsshop/image-service-1.0.jar:v1.0
            docker push $(acrRegistry)/ctsshop/image-service-1.0.jar:v1.0
          displayName: 'Push IMAGE-SERVICE Docker Image to ACR'
        - script: |
            docker tag ctsshop/payment-service-1.0.jar:v1.0 $(acrRegistry)/ctsshop/payment-service-1.0.jar:v1.0
            docker push $(acrRegistry)/ctsshop/payment-service-1.0.jar:v1.0
          displayName: 'Push PAYMENT-SERVICE Docker Image to ACR'
        - script: |
            #rev=`echo $(Build.BuildNumber) | cut -d "." -f 2`
            body="[{\"op\":\"test\",\"path\":\"\/rev\",\"value\":1},{\"op\":\"add\",\"path\":\"\/fields\/System.State\",\"value\":\"Done\"}]"
            IFS=',' read -ra devIDs <<< "$(devIDs)"
            for devID in "${devIDs[@]}"; do
              if [[ $(az rest --method get --headers Authorization="Basic "$(b64pat) --url https://dev.azure.com/$(organization)/$(project)/_apis/wit/workitems/$devID?api-version=6.0 | jq '.fields."System.State"' | tr -d '"') = "To Do" ]];then
                url="https://dev.azure.com/$(organization)/$(project)/_apis/wit/workitems/$devID?api-version=6.0"
                az rest --method patch --headers Authorization="Basic "$(b64pat) Content-Type=application/json-patch+json --url $url --body $body
              fi  
            done
            IFS=',' read -ra devOpsIDs <<< "$(devOpsIDs)"
            for devOpsID in "${devOpsIDs[@]}"; do
              if [[ $(az rest --method get --headers Authorization="Basic "$(b64pat) --url https://dev.azure.com/$(organization)/$(project)/_apis/wit/workitems/$devOpsID?api-version=6.0 | jq '.fields."System.State"' | tr -d '"') = "To Do" ]];then
                url="https://dev.azure.com/$(organization)/$(project)/_apis/wit/workitems/$devOpsID?api-version=6.0"
                az rest --method patch --headers Authorization="Basic "$(b64pat) Content-Type=application/json-patch+json --url $url --body $body
              fi  
            done
          displayName: 'Update WorkItems'
      dependsOn: PREBUILD_QA
      condition: succeeded()       
# - stage: DEPLOYMENT
#   displayName: DEPLOYMENT TO AKS
#   dependsOn:
#    - BUILD_PIPELINE_FRONTEND
#    - BUILD_PIPELINE_BACKEND
#   condition: succeeded()
#   jobs:
#     - job: DEPLOYMENT
#       pool:
#         vmImage: 'ubuntu-latest'
#         variables:
#           backendPublicIP: $(publicIP)
#           privateIP: $(publicIP)
#           region: $(regionprimary)
#           bucket: $(bucketurl)
#       steps:
#       - checkout: FrontendRepo
#       - task: Kubernetes@1
#         inputs:
#           connectionType: Kubernetes Service Connection
#           kubernetesServiceEndpoint: MYAKSCONNECTION
#           command: login
#         displayName: 'Login to AKS'
#       - task: Bash@3
#         displayName: 'Deployment'        
#         inputs:
#           targetType: 'inline'
#           script: |
#             kubectl create secret docker-registry mykubetokenacrs --docker-server=$(acrRegistry) --docker-username=00000000-0000-0000-0000-000000000000 --docker-password=$(azureACRToken)
#             kubectl run service-registry --image=$(acrRegistry)/ctsshop/service-registry-1.0.jar:v1.0 --overrides='{ "apiVersion": "v1", "spec": { "imagePullSecrets": [{"name": "mykubetokenacrs"}] } }' --port=8180
#             kubectl expose pod service-registry --port=8180 --target-port=8180 --name=service-registry --type=LoadBalancer
#             bash -c 'external_ip=""; while [ -z $external_ip ]; do echo "Waiting for end point..."; external_ip=$(kubectl get svc service-registry --template="{{range .status.loadBalancer.ingress}}{{.ip}}{{end}}"); [ -z "$external_ip" ] && sleep 10; done; echo "End point ready-" && echo $external_ip; export endpoint=$external_ip'
#             kubectl run catalogue-service --image=$(acrRegistry)/ctsshop/catalogue-service-1.0.jar:v1.0 --overrides='{ "apiVersion": "v1", "spec": { "imagePullSecrets": [{"name": "mykubetokenacrs"}] } }' --port=8181
#             kubectl expose pod catalogue-service --port=8181 --target-port=8181 --name=catalogue-service --type=LoadBalancer
#             kubectl run customer-service --image=$(acrRegistry)/ctsshop/customer-service-1.0.jar:v1.0 --overrides='{ "apiVersion": "v1", "spec": { "imagePullSecrets": [{"name": "mykubetokenacrs"}] } }' --port=8182
#             kubectl expose pod customer-service --port=8182 --target-port=8182 --name=customer-service --type=LoadBalancer
#             kubectl run image-service --image=$(acrRegistry)/ctsshop/image-service-1.0.jar:v1.0 --overrides='{ "apiVersion": "v1", "spec": { "imagePullSecrets": [{"name": "mykubetokenacrs"}] } }' --port=8183
#             kubectl run payment-service --image=$(acrRegistry)/ctsshop/payment-service-1.0.jar:v1.0 --overrides='{ "apiVersion": "v1", "spec": { "imagePullSecrets": [{"name": "mykubetokenacrs"}] } }' --port=8184
#             externalip=$(kubectl get services/service-registry -o json | jq '.status.loadBalancer.ingress[0].ip' | tr -d '"')
#             echo $externalip
#             kubectl run frontendtestapp --image=$(acrRegistry)/digitalshopify --overrides='{ "apiVersion": "v1", "spec": { "imagePullSecrets": [{"name": "mykubetokenacrs"}] } }' --port=3000 --expose=true --env="REACT_APP_API=$externalip" -- npm start
#             kubectl expose pod frontendtestapp --port=3000 --target-port=3000 --name=frontendtestapp-pod-loadbalancer --type=LoadBalancer
#             bash -c 'external_ip=""; while [ -z $external_ip ]; do echo "Waiting for end point..."; external_ip=$(kubectl get svc frontendtestapp-pod-loadbalancer --template="{{range .status.loadBalancer.ingress}}{{.ip}}{{end}}"); [ -z "$external_ip" ] && sleep 10; done; echo "End point ready-" && echo $external_ip; export endpoint=$external_ip'
#             kubectl expose pod image-service --port=8183 --target-port=8183 --name=image-service --type=LoadBalancer
#             kubectl expose pod payment-service --port=8184 --target-port=8184 --name=payment-service --type=LoadBalancer